--forms module - Created on 27-Feb-2023

--[[
	In this module - Form record and it's functionalities.

	These are the important functions in Form record
	-------------------------------------------------
	Form.new()  - Constructor
	Form:createHandle() - Creating the window handle.
	Form:show() - Display the form and entering to the main loop if it's the first form.
	Form:setBackColor() - Set the back ground color
	Form:setGradientBackColor - Set gradient back gound color
	Form:hide() - Hide the form

	For properties & Events - Look for the Form record declaration.
	Private fields are starting with an underscore.
	--------------------------------------------------
]]


require "nforms.api_messages"
require "nforms.apifuncs"
require "nforms.color"
require "nforms.font"
require "nforms.common"
require "nforms.controls"
require "hashmap"
require "io"



-- require 'nelua.utils.fs'

--Window constants
	local CS_VREDRAW  : DWORD <comptime> = 0x0001
	local CS_HREDRAW : DWORD <comptime> = 0x0002
	local CS_OWNDC  : DWORD <comptime> = 0x0020

	--Get window long ptr Constants
	global GWL_EXSTYLE <comptime> = -20
	global GWLP_HINSTANCE <comptime> = -6
	global GWLP_ID <comptime> = -12
	global GWL_STYLE <comptime> = -16
	global GWLP_USERDATA <comptime> = -21
	global GWLP_WNDPROC <comptime> = -4

	local SC_MINIMIZE : UINT <comptime> = 0xF020
	local SC_RESTORE : UINT <comptime> = 0xF120
	local SC_MAXIMIZE : UINT <comptime> = 0xF030

	local TME_HOVER : DWORD <comptime> = 0x00000001
	local TME_LEAVE : DWORD <comptime> = 0x00000002
	local HOVER_DEFAULT : DWORD <comptime> = 0xFFFFFFFF

	local SW_SHOW = 5
	local SW_HIDE = 0
	local MF_POPUP = 0x00000010
	local MF_SEPARATOR = 0x00000800
	local MF_STRING = 0x00000000
	local MF_POPUP = 0x00000010
	local MF_CHECKED = 0x00000008

	-- Window Styles Constants
	global WS_OVERLAPPED : DWORD <comptime> = 0x00000000
	global WS_MAXIMIZEBOX : DWORD <comptime> = 0x00010000
	global WS_MINIMIZEBOX : DWORD <comptime> = 0x00020000
	global WS_THICKFRAME : DWORD <comptime> = 0x00040000
	global WS_SYSMENU : DWORD <comptime> = 0x00080000
	global WS_BORDER : DWORD <comptime> = 0x00800000
	global WS_CAPTION : DWORD <comptime> = 0x00C00000
	global WS_VISIBLE : DWORD <comptime> = 0x10000000
	global WS_POPUP : DWORD <comptime> = 0x80000000
	global WS_MAXIMIZE : DWORD <comptime> = 0x01000000
	global WS_MINIMIZE : DWORD <comptime> = 0x20000000
	global WS_TABSTOP : DWORD <comptime> = 0x00010000
	global WS_CLIPCHILDREN : DWORD <comptime> = 0x02000000
	global WS_CLIPSIBLINGS : DWORD <comptime> = 0x04000000
	global WS_GROUP : DWORD  <comptime> = 0x00020000
	global WS_DLGFRAME : DWORD  <comptime> = 0x00400000

	global WS_OVERLAPPEDWINDOW : DWORD <comptime> = WS_OVERLAPPED|WS_CAPTION|WS_SYSMENU|WS_THICKFRAME|WS_MINIMIZEBOX|WS_MAXIMIZEBOX
	global WS_POPUPWINDOW : DWORD    <comptime> = WS_POPUP|WS_BORDER|WS_SYSMENU

	global WS_CHILD : DWORD <comptime> = 0x40000000
	global WS_EX_LEFT : DWORD <comptime> = 0x00000000
	global WS_EX_LTRREADING : DWORD <comptime> = 0x00000000
	global WS_EX_RIGHTSCROLLBAR : DWORD <comptime> = 0x00000000
	global WS_EX_WINDOWEDGE : DWORD <comptime> = 0x00000100
	global WS_EX_CONTROLPARENT : DWORD <comptime> = 0x00010000
	global WS_EX_APPWINDOW : DWORD  <comptime> = 0x00040000
	global WS_EX_TOOLWINDOW : DWORD  <comptime> = 128
	global WS_EX_TOPMOST : DWORD  <comptime> = 8
	global WS_EX_CLIENTEDGE : DWORD  <comptime> = 0x00000200
	global WS_EX_OVERLAPPEDWINDOW : DWORD  <comptime> = 0x00000300
	global WS_EX_DLGMODALFRAME : DWORD  <comptime> = 0x00000001
	global WS_EX_NOPARENTNOTIFY : DWORD  <comptime> = 0x00000004
	global WS_EX_TRANSPARENT : DWORD  <comptime> = 0x00000020

	local menuTxtFlag :DWORD <comptime> = DT_LEFT | DT_SINGLELINE | DT_VCENTER

	-- Different window styles
	local fixedSingleExStyle: DWORD = WS_EX_LEFT|WS_EX_LTRREADING|WS_EX_RIGHTSCROLLBAR|WS_EX_WINDOWEDGE|WS_EX_CONTROLPARENT|WS_EX_APPWINDOW
	local fixedSingleStyle : DWORD = WS_OVERLAPPED|WS_TABSTOP|WS_MAXIMIZEBOX|WS_MINIMIZEBOX|WS_GROUP|WS_SYSMENU|WS_DLGFRAME|WS_BORDER|WS_CAPTION|WS_CLIPCHILDREN|WS_CLIPSIBLINGS
	local fixed3DExStyle : DWORD = WS_EX_LEFT|WS_EX_LTRREADING|WS_EX_RIGHTSCROLLBAR|WS_EX_WINDOWEDGE|WS_EX_CLIENTEDGE|WS_EX_CONTROLPARENT|WS_EX_APPWINDOW|WS_EX_OVERLAPPEDWINDOW
	local fixed3DStyle : DWORD = WS_OVERLAPPED|WS_TABSTOP|WS_MAXIMIZEBOX|WS_MINIMIZEBOX|WS_GROUP|WS_SYSMENU|WS_DLGFRAME|WS_BORDER|WS_CAPTION|WS_CLIPCHILDREN|WS_CLIPSIBLINGS
	local fixedDialogExStyle : DWORD = WS_EX_LEFT|WS_EX_LTRREADING|WS_EX_RIGHTSCROLLBAR|WS_EX_DLGMODALFRAME|WS_EX_WINDOWEDGE|WS_EX_CONTROLPARENT|WS_EX_APPWINDOW
	local fixedDialogStyle : DWORD = WS_OVERLAPPED|WS_TABSTOP|WS_MAXIMIZEBOX|WS_MINIMIZEBOX|WS_GROUP|WS_SYSMENU|WS_DLGFRAME|WS_BORDER|WS_CAPTION|WS_CLIPCHILDREN|WS_CLIPSIBLINGS
	local normalWinExStyle: DWORD = WS_EX_LEFT|WS_EX_LTRREADING|WS_EX_RIGHTSCROLLBAR|WS_EX_WINDOWEDGE|WS_EX_CONTROLPARENT|WS_EX_APPWINDOW
	local normalWinStyle : DWORD = WS_OVERLAPPEDWINDOW|WS_TABSTOP| WS_BORDER|WS_CLIPCHILDREN|WS_CLIPSIBLINGS
	local fixedToolExStyle : DWORD = WS_EX_LEFT|WS_EX_LTRREADING|WS_EX_RIGHTSCROLLBAR|WS_EX_TOOLWINDOW|WS_EX_WINDOWEDGE|WS_EX_CONTROLPARENT|WS_EX_APPWINDOW
	local fixedToolStyle : DWORD = WS_OVERLAPPED|WS_TABSTOP|WS_MAXIMIZEBOX|WS_MINIMIZEBOX|WS_GROUP|WS_SYSMENU|WS_DLGFRAME|WS_BORDER|WS_CAPTION|WS_CLIPCHILDREN|WS_CLIPSIBLINGS
	local sizableToolExStyle : DWORD = WS_EX_LEFT|WS_EX_LTRREADING|WS_EX_RIGHTSCROLLBAR|WS_EX_TOOLWINDOW|WS_EX_WINDOWEDGE|WS_EX_CONTROLPARENT|WS_EX_APPWINDOW
	local sizableToolStyle : DWORD = WS_OVERLAPPED|WS_TABSTOP|WS_MAXIMIZEBOX|WS_MINIMIZEBOX|WS_GROUP|WS_THICKFRAME|WS_SYSMENU|WS_DLGFRAME|WS_BORDER|WS_CAPTION|WS_OVERLAPPEDWINDOW|WS_CLIPCHILDREN|WS_CLIPSIBLINGS
--End of Window constants

-- local function getChildControl(ctl: pointer, ctype: ControlType) : auto
-- 	switch ctype do
-- 	case ControlType.Button then return (@*Button)(ctl)
-- 	end
-- 	return nilptr
-- end
-- Just to hold some app level informations.

-- /////////////////////////////////
global app : Application
-- ////////////////////////////////

local function windowProc(hw : HWND, msg: cuint, wp: WPARAM, lp: LPARAM): LRESULT <forwarddecl> end
local function regWindow() <forwarddecl> end
function ContextMenu:show(lpm: LPARAM) <forwarddecl> end
function MenuBar:createHandle() <forwarddecl> end
function MenuItem:getChildMenuFromID(idnum: UINT) : (boolean, *MenuItem) <forwarddecl> end
function Timer:timer_dtor() <forwarddecl> end

-- local function getChildControl(ctl: pointer, ctype: ControlType) : auto <forwarddecl> end
-- global MenuClickHandler: type <cimport,nodecl> = @function(HWND, UINT, WPARAM, LPARAM): LRESULT


function Form.new(title: string, width: integer, height: integer ) : *Form --Constructor
	local this : *Form = default_allocator:new(@Form)
	this._count = this._count + 1
	this.name = string.format("Form_%d", this._count)
	this.text = title
	this.width = width == 0 and 550 or width
	this.height = height == 0 and 400 or height
	this.xpos = 100
	this.ypos = 100
	this.style = FormStyle.Sizable
	this.maximizeBox = true
	this.minimizeBox = true
	this.backColor = Color.new(0xF0EFEB)
	this._isTextable = true
	this._cidNumber = 100
	return this
end


##[[
	local function getIconPath()
		require'nelua.utils.fs'
		local x = fs.scriptname()
		local y = fs.dirname(x)
		return string.format("%s\\nforms_icon.ico", y)
	end
]]##


--Private function
function regWindow()
	local ico = toUTF16(#[getIconPath()]#)
	app.className = "NForms_Window_Nelua"
	app.hInstance = GetModuleHandleW(nilptr)
	app.menuNumber = 100
	local wcEx : WNDCLASSEXW
	local clr = (@COLORREF)(0x00EBEFF0)
	wcEx.cbSize = #WNDCLASSEXW
	wcEx.style = CS_HREDRAW|CS_VREDRAW
	wcEx.lpfnWndProc = windowProc
	wcEx.cbClsExtra = 0
	wcEx.cbWndExtra = 256
	wcEx.hInstance = app.hInstance
	wcEx.hIcon = LoadImageW(nilptr, ico, 1, 0, 0, 16|64)
	wcEx.hCursor = LoadCursorW(nilptr, IDC_ARROW)
	wcEx.hbrBackground = (@HBRUSH)(CreateSolidBrush(clr))  --(@HBRUSH)(6)
	wcEx.lpszMenuName = nilptr
	wcEx.lpszClassName = toUTF16(app.className)
	RegisterClassExW(&wcEx)
end

--Private function
function Form:setStyles()
	local mxFlag = false
    switch self.style do
    case FormStyle.None then
        self._exStyle = 0x00050000
        self._winStyle = 0x16010000
    case FormStyle.FixedSingle then
        self._exStyle = fixedSingleExStyle
        self._winStyle = fixedSingleStyle
        mxFlag = true
    case FormStyle.Fixed3D then
        self._exStyle = fixed3DExStyle
        self._winStyle = fixed3DExStyle
        mxFlag = true
    case FormStyle.FixedDialog then
        self._exStyle = fixedDialogExStyle
        self._winStyle = fixedDialogStyle
        mxFlag = true
    case FormStyle.FixedTool then
        self._exStyle = fixedToolExStyle
        self._winStyle = fixedToolStyle
    case FormStyle.Sizable then
        self._exStyle = normalWinExStyle
        self._winStyle = normalWinExStyle|WS_OVERLAPPEDWINDOW
    case FormStyle.SizableTool then
        self._exStyle = sizableToolExStyle
        self._winStyle = sizableToolStyle -- con.WS_OVERLAPPEDWINDOW
        mxFlag = true
    case FormStyle.Hidden then
        self._exStyle = WS_EX_TOOLWINDOW
        self._winStyle = WS_BORDER
    end
    if mxFlag then
        if not self.maximizeBox then self._winStyle = self._winStyle ~ WS_MAXIMIZEBOX end
        if not self.minimizeBox then self._winStyle = self._winStyle ~ WS_MINIMIZEBOX end
    end
    if self.topMost then self._exStyle = self._exStyle or WS_EX_TOPMOST end
    if self.formState == FormState.Maximized then self._winStyle = self._winStyle|WS_MAXIMIZE end
end

--Private function
function Form:setPos()
	switch self.formPos do
	case FormPosition.Center then
		self.xpos = (app.screenWidth - self.width) / 2
        self.ypos = (app.screenHeight - self.height) / 2
	case FormPosition.TopMid then self.xpos = (app.screenWidth - self.width) / 2
	case FormPosition.TopRight then self.xpos = app.screenWidth - self.width
	case FormPosition.MidLeft then self.ypos = (app.screenHeight - self.height) / 2
	case FormPosition.MidRight then
		self.xpos = app.screenWidth - self.width
        self.ypos = (app.screenHeight - self.height) / 2
	case FormPosition.BottomLeft then self.ypos = app.screenHeight - self.height
	case FormPosition.BottomMid then
		self.xpos = (app.screenWidth - self.width) / 2
        self.ypos = app.screenHeight - self.height
	case FormPosition.BottomRight then
		self.xpos = app.screenWidth - self.width
        self.ypos = app.screenHeight - self.height
    end
end

-- function Form:createChildHandles()
-- 	if self._controls.size > 0 then
-- 		for _, ctl in ipairs(self._controls) do
-- 			local child = getChildControl(ctl.data, ctl.dtype)
-- 			if child.handle == nilptr then child:createHandle() end
-- 		end
-- 	end
-- end



--Public function
function Form:createHandle()
	--InitCommonControls()
	if not app.started then
		app.started = true
		app.screenWidth = GetSystemMetrics(0)
		app.screenHeight = GetSystemMetrics(1)
		regWindow()
	end
	self.hInstance = app.hInstance
	self.font = Font.new()
	self:setStyles()
	self:setPos()
	self.handle = CreateWindowExW(self._exStyle,
                                               toUTF16(app.className),
                                    toUTF16(self.text),
                                    self._winStyle, self.xpos, self.ypos, self.width, self.height,
                                    nilptr, nilptr, app.hInstance, nilptr)
	if self.handle ~= nilptr then
		self._isCreated = true
		SetWindowLongPtrW(self.handle, GWLP_USERDATA, (@LONG_PTR) (self))
		self.font:setFontInternal(self.handle)
	else
		print("not cretaed handle")
	end
end

function Form:setText(txt: string)
	self.text = txt
	if self._isCreated then	setControlText(self.handle, txt) end
end

local function mainLoop()
	local ms : MSG
	while GetMessageW(&ms, nilptr, 0, 0) ~= 0 do
	  TranslateMessage(&ms)
	  DispatchMessageW(&ms)
	end
end

--Public function
function Form:show()
	ShowWindow(self.handle, SW_SHOW)
	UpdateWindow(self.handle)
	if self.menubar ~= nilptr then self.menubar:createHandle() end
	if not app.mainLoopStarted then
		app.mainLoopStarted = true
		app.mainWinHandle = self.handle
		mainLoop()
	end
end

function Form:hide() ShowWindow(self.handle, SW_HIDE) end

function Form:setBackColor(clr: uinteger)
	self.backColor = Color.new(clr)
	self._drawMode = FormDrawMode.FlatColor
	suddenRedraw(self)
end

function Form:setGradientBackColor(clr1: uinteger, clr2: uinteger, top2Bottom: boolean)
	self._topToBottom = top2Bottom
	self._gdraw.c1 = Color.new(clr1)
	self._gdraw.c2 = Color.new(clr2)
	self._drawMode = FormDrawMode.Gradient
	suddenRedraw(self)
end

function Form:addTimer(interval: uinteger, tickHandler: EventHandler): *Timer
	local this : *Timer = default_allocator:new(@Timer)
	this.interval = interval == 0 and 200 or interval
	this.onTick = tickHandler
	this._pHwnd = self.handle
	this._idNum = (@UINT_PTR)(this)
	self._timerMap[this._idNum] = this
	return this
end

function Timer:start()
	self._isEnabled = true
	SetTimer(self._pHwnd, self._idNum, self.interval, nilptr)
end

function Timer:stop()
	KillTimer(self._pHwnd, self._idNum)
	self._isEnabled = false
end

function Timer:timer_dtor()
	if self._isEnabled then 
		KillTimer(self._pHwnd, self._idNum) 
		print("Timer freed")
	end
	self = nilptr
end

--Private function
function Form:setBKGInternal(wpm: WPARAM) : LRESULT
	local hdc: HDC = (@HDC)(wpm)
	local hbr : HBRUSH
	local rct: RECT
	GetClientRect(self.handle, &rct)
	if self._drawMode == FormDrawMode.FlatColor then
		hbr = CreateSolidBrush(self.backColor.ref)
	elseif self._drawMode == FormDrawMode.Gradient then
		hbr = createGradientBrush(hdc, rct, self._gdraw.c1, self._gdraw.c2, self._topToBottom)
	end
	FillRect(hdc, &rct, hbr)
	DeleteObject(hbr)
	return 1
end

--Private function
	function Form:getMenuFromID(menuId: UINT): (boolean, *MenuItem)
		if #self._menuList > 0 then
			for _,menu in ipairs(self._menuList) do
				if menu.menuID == menuId then return true, menu end
			end
		end
		return false, nilptr
	end

	function Form:getMenuFromHmenu(hmenu: HMENU): (boolean, *MenuItem)
	    if #self._menuList > 0 then
	        for _, menu in ipairs(self._menuList) do
	            if menu.handle == hmenu then return true, menu end
	        end
	    end
	    return false, nilptr
	end

	local function trackMouse(hw: HWND)
		local tme : TRACKMOUSEEVENT
	    tme.cbSize = #TRACKMOUSEEVENT
	    tme.dwFlags = TME_HOVER | TME_LEAVE
	    tme.dwHoverTime = HOVER_DEFAULT
	    tme.hwndTrack = hw
	    TrackMouseEvent(&tme)
	end

	function Form:_handleWmMeasureItem(lpm: LPARAM): LRESULT
		local pmi = (@LPMEASUREITEMSTRUCT)(lpm)
        local mi = (@*MenuItem)(pmi.itemData)
        -- ptf("wm measure item - menu name : %s\n", mi.text)
        if mi.kind == MenuType.BaseMenu or mi.kind == MenuType.DropDownMenu then
            local hdc = GetDC(self.handle)
            local size : SIZE
            GetTextExtentPoint32W(hdc, mi._wideText, #mi.text, &size)
            ReleaseDC(self.handle, hdc)
            pmi.itemWidth = size.cx
            pmi.itemHeight = size.cy + 10
        else
            pmi.itemWidth = 150
            pmi.itemHeight = 25
        end
        return (@LRESULT)(1)
	end

	function Form:_handleWmDrawItem(lpm: LPARAM) : LRESULT
		local dis = (@LPDRAWITEMSTRUCT)(lpm)
        local mi = (@*MenuItem)(dis.itemData)
        --ptf("wm draw item - menu name : %s\n", mi.text)
        local txtClrRef = mi.fgColor.ref
        if dis.itemState == 320 or dis.itemState == 257 then
            local rc : RECT
            if mi._isEnabled then
                rc = RECT{dis.rcItem.left + 4, dis.rcItem.top + 2, dis.rcItem.right, dis.rcItem.bottom - 2}
                FillRect(dis.hDC, &rc, self.menubar._menuHotBgBrush)
                FrameRect(dis.hDC, &rc, self.menubar._menuFrameBrush)
                txtClrRef = 0x00000000
            else
                FillRect(dis.hDC, &rc, self.menubar._menuGrayBrush)
                txtClrRef = self.menubar._menuGrayCref
            end
       	else
            -- ptf("draw menu : %s\n", mi.text)
            FillRect(dis.hDC, &dis.rcItem, self.menubar._menuDefBgBrush)
            if not mi._isEnabled then txtClrRef = self.menubar._menuGrayCref end
        end

        SetBkMode(dis.hDC, 1)
        dis.rcItem.left = mi.kind == MenuType.BaseMenu and dis.rcItem.left + 10 or dis.rcItem.left + 25
        SelectObject(dis.hDC, (@HGDIOBJ)(self.menubar.font.handle))
        SetTextColor(dis.hDC, txtClrRef)
        DrawTextW(dis.hDC, mi._wideText, -1, &dis.rcItem, menuTxtFlag)
        return 0
	end

-- End of private funcs

-- Event Handler functions

	function Form:wmMouseMoveHandler(msg: UINT, wp: WPARAM, lp: LPARAM)
		if not self._isMouseTracking then
			self._isMouseTracking = true
			trackMouse(self.handle)
			if self._isMouseEntered then
				if self.onMouseEnter ~= nilptr then
					local ea : EventArgs = {}
					self.onMouseEnter(self, &ea)
				end
			end
		end

		if self.onMouseMove ~= nilptr then
			local mea = MouseEventArgs.new(msg, wp, lp)
			self.onMouseMove(self, &mea)
		end
	end

	function Form:wmMouseLeaveHandler()
		if self._isMouseTracking then
			self._isMouseTracking = false
			self._isMouseEntered = false
		end

		if self.onMouseLeave ~= nilptr then
			local ea: EventArgs = {}
			self.onMouseLeave(self, &ea)
		end
	end

	function Form:wmSysCommandHandler(wp: WPARAM)
		local sysMsg : UINT = (wp & 0xFFF0)
		switch sysMsg do
		case SC_MINIMIZE then
			if self.onMinimized ~= nilptr then
				local ea : EventArgs = {}
				self.onMinimized(self, &ea)
			end
		case SC_MAXIMIZE then
			if self.onMaximized ~= nilptr then
				local ea : EventArgs = {}
				self.onMaximized(self, &ea)
			end
		case SC_RESTORE then
			if self.onRestored ~= nilptr then
				local ea : EventArgs = {}
				self.onRestored(self, &ea)
			end
		end
	end

	function Form:keyDownHandler(wpm: WPARAM)
		if self.onKeyDown ~= nilptr then
			local kea =KeyEventArgs.new(wpm)
			self.onKeyDown(self, &kea)
		end
	end

	function Form:keyUpHandler(wpm: WPARAM)
		if self.onKeyUp ~= nilptr then
			local kea =KeyEventArgs.new(wpm)
			self.onKeyUp(self, &kea)
		end
	end

	function Form:keyPressHandler(wpm: WPARAM)
		if self.onKeyPress ~= nilptr then
			local kea =KeyEventArgs.new(wpm)
			self.onKeyPress(self, &kea)
		end
	end

	function Form:wmSizingHandler(msg: UINT, wp: WPARAM, lp: LPARAM)
		local sea = SizeEventArgs.new(msg, wp, lp)
		self.width = sea.formRect.right - sea.formRect.left
		self.height = sea.formRect.bottom - sea.formRect.top
		if self.onSizeChanging ~= nilptr then
			self.onSizeChanging(self, &sea)
		end
	end

	function Form:wmSizeHandler(msg: UINT, wp: WPARAM, lp: LPARAM)
		local sea = SizeEventArgs.new(msg, wp, lp)
		if self.onSizeChanged ~= nilptr then
			self.onSizeChanged(self, &sea)
		end
	end

	function Form:wmMovingHandler(lp: LPARAM)
		local rct = (@LPRECT)(lp)
		self.xpos = rct.left
		self.ypos = rct.top
		if self.onMoving ~= nilptr then
			local ea : EventArgs = {}
			self.onMoving(self, &ea)
		end
	end

	function Form:wmMoveHandler(lp: LPARAM)
		local rct = (@LPRECT)(lp)
		self.xpos = getXFromLPARAM(lp)
		self.ypos = getYFromLPARAM(lp)
		if self.onMoved ~= nilptr then
			local ea : EventArgs = {}
			self.onMoved(self, &ea)
		end
	end

	function Form:wmCloseHandler() : boolean
		if self.onClosing ~= nilptr then
			local ea : EventArgs = {}
			self.onClosing(self, &ea)
			return ea.cancelled
		end
		return false
	end

	function Form:wmActivateAppHandler(wp: WPARAM)
		if self.onActivate ~= nilptr or self.onDeActivate ~= nilptr then
			local ea : EventArgs = {}
			local activated : boolean = wp == 1 and true or false
			if activated then
				if self.onActivate ~= nilptr then self.onActivate(self, &ea) end
			else
				if self.onDeActivate ~= nilptr then self.onDeActivate(self, &ea) end
			end
		end
	end

	function Form:wmShowWindowHandler()
		if self.onLoad ~= nilptr then
			local ea : EventArgs = {}
			self.onLoad(self, &ea)
		end
	end

	function Form:destroy()
		DeleteObject(self.font.handle)
		-- if self._drawMode == FormDrawMode.Gradient then self._gdraw:destroy() end
		if #self._timerMap > 0 then
			for up, ptmr in pairs(self._timerMap) do
				local tm : *Timer = (@*Timer)(ptmr)
				tm:timer_dtor() 
			end
		end	
		self = nilptr
	end

	function Form:wmDestroyHandler(): boolean
		local ea : EventArgs = {}
		if self.onClosed ~= nilptr then
			self.onClosed(self, &ea)
			if ea.cancelled then return true end
		end
		self:destroy()
		if app.mainWinHandle == self.handle then PostQuitMessage(0) end
		return false
	end
-- End


function windowProc(hw : HWND, msg: UINT, wpm: WPARAM, lpm: LPARAM): LRESULT
	local this = (@*Form) (GetWindowLongPtrW(hw, GWLP_USERDATA))
	switch msg do
	case WM_DESTROY then if this:wmDestroyHandler() then return 0 end
	case WM_LBUTTONDOWN then leftMouseDownHandler(this, msg, wpm, lpm)
	case WM_LBUTTONUP then leftMouseUpHandler(this, msg, wpm, lpm)
	case MM_MOUSE_LB_CLICK then leftMouseClickHandler(this)
	case WM_RBUTTONDOWN then rightMouseDownHandler(this, msg, wpm, lpm)
	case WM_RBUTTONUP then rightMouseUpHandler(this, msg, wpm, lpm)
	case MM_MOUSE_RB_CLICK then rightMouseClickHandler(this)
	case WM_MOUSEHWHEEL then mouseScrollHandler(this, msg, wpm, lpm)
	case WM_MOUSEMOVE then this:wmMouseMoveHandler(msg, wpm, lpm)
	case WM_MOUSELEAVE then this:wmMouseLeaveHandler()
	case WM_SYSCOMMAND then this:wmSysCommandHandler(wpm)
	case WM_KEYDOWN, WM_SYSKEYDOWN then this:keyDownHandler(wpm)
	case WM_KEYUP, WM_SYSKEYUP then this:keyUpHandler(wpm)
	case WM_CHAR then this:keyPressHandler(wpm)
	case WM_SIZING then this:wmSizingHandler(msg, wpm, lpm)
	case WM_SIZE then this:wmSizeHandler(msg, wpm, lpm)
	case WM_MOVING then this:wmMovingHandler(lpm)
	case WM_MOVE then this:wmMoveHandler(lpm)
	case WM_CLOSE then if this:wmCloseHandler() then return 0 end
	case WM_ACTIVATEAPP then this:wmActivateAppHandler(wpm)
	case WM_SHOWWINDOW then this:wmShowWindowHandler()
	case WM_MEASUREITEM then return this:_handleWmMeasureItem(lpm)
	case WM_DRAWITEM then return this:_handleWmDrawItem(lpm)
	case MM_THREAD_MSG then
		if this.onThreadMsg ~= nilptr then this.onThreadMsg(wpm, lpm) end

	case WM_TIMER then
		local okay, ptimer = this._timerMap:has_and_get((@UINT_PTR)(wpm))
		if okay then 
			local timer = (@*Timer)(ptimer)
			if timer.onTick ~= nilptr then
				local ea : EventArgs = {}
				timer.onTick(this, &ea)
			end			
		end

	case WM_COMMAND then
		switch hiWord(wpm) do
		case 0 then -- from menu
			local menu_okay, menu = this:getMenuFromID((@UINT)(loWord(wpm)))
			if menu_okay then
				local ea : EventArgs = {}
				menu.onClick(menu, &ea)
			end
		-- case 1 then -- accelerator keys
		case 2 then
			local ctHwnd = (@HWND)(lpm)
			return SendMessageW(ctHwnd, MM_CTL_COMMAND, wpm, lpm)
		end

	case WM_CONTEXTMENU then
		if this.contextMenu ~= nilptr then this.contextMenu:show(lpm) end

	case WM_ERASEBKGND then
		if this._drawMode ~= FormDrawMode.Default then return this:setBKGInternal(wpm) end

	case WM_HSCROLL then return SendMessageW((@HWND)(lpm), MM_HSCROLL, wpm, lpm)
    case WM_VSCROLL then return SendMessageW((@HWND)(lpm), MM_VSCROLL, wpm, lpm)

	case WM_NOTIFY then
		local nmhdr = (@*NMHDR)(lpm)
		return SendMessageW(nmhdr.hwndFrom, MM_NOTIFY_REFLECT, wpm, lpm)

	case WM_CTLCOLOREDIT then
		local ctHwnd = (@HWND)(lpm)
		return SendMessageW(ctHwnd, MM_EDIT_COLOR, wpm, lpm)

	case WM_CTLCOLORSTATIC then
		local ctHwnd = (@HWND)(lpm)
		return SendMessageW(ctHwnd, MM_LABEL_COLOR, wpm, lpm)

	case WM_CTLCOLORLISTBOX then
		-- Chances are there this message is came from a combo's listbox.
		-- In such cases, we need to dispatch this message to that combo's wndproc.
		local ctHwnd = (@HWND)(lpm)
		local res, cmbHwnd = this.comboMap:has_and_get(ctHwnd)
		if res then
			return SendMessageW(cmbHwnd, MM_LIST_COLOR, wpm, lpm)
		else
			return SendMessageW(ctHwnd, MM_LIST_COLOR, wpm, lpm)
		end

	case WM_MENUSELECT then
        local menu_okay, pmenu = this:getMenuFromHmenu((@HMENU)(lpm))
       	local mid = (@UINT)(loWord(wpm)) -- Could be an id of a child menu or index of a child menu
        local hwwpm = hiWord(wpm)
        if menu_okay then
        	menu_okay = false
            local menu : *MenuItem
            switch hwwpm do
            case 33152 then -- A normal child menu. We can use mid ad menu id.
                menu_okay, menu = this:getMenuFromID(mid)
            case 33168 then -- A popup child menu. We can use mid as index.
                menu_okay, menu = pmenu:getChildMenuFromID(mid)
        	end
            if menu_okay and menu.onFocus ~= nilptr then
                local ea : EventArgs = {}
                menu.onFocus(menu, &ea)
            end
        end

    case WM_INITMENUPOPUP then
        local menu_okay, menu = this:getMenuFromHmenu((@HMENU)(wpm))
        if menu_okay and menu.onPopup ~= nilptr then
            local ea : EventArgs = {}
           	menu.onPopup(menu, &ea)
        end

    case WM_UNINITMENUPOPUP then
        local menu_okay, menu = this:getMenuFromHmenu((@HMENU)(wpm))
        if menu_okay and menu.onCloseup ~= nilptr then
            local ea : EventArgs = {}
            menu.onCloseup(menu, &ea)
        end
	end


	return DefWindowProcW(hw, msg, wpm, lpm)
end

-- ===========================================MENU RELATED FUNCTIONS=================================================

	local function menubar_additems_internal(mbar: *MenuBar, items: span(string)) <forwarddecl> end

	function MenuBar:addItems(items: span(string))
		menubar_additems_internal(self, items)
	end

	function MenuBar.new(frm: *Form, menuitems: span(string)): *MenuBar
		local this: *MenuBar = default_allocator:new(@MenuBar)
		this.handle = CreateMenu()
		this._pForm = frm
	    this.font = Font.new("Tahoma", 11)
	    this._menuGrayBrush = Color.getHBrush(0xced4da)
	    this._menuGrayCref = Color.getColorRef(0x979dac)
	    this._pForm.menubar = this
	    menubar_additems_internal(this, menuitems)
	    return this
	end

	function MenuItem.new(menutxt: string, mtype: MenuType, pHandle: HMENU, indexNum: uinteger): *MenuItem
		local this : *MenuItem = default_allocator:new(@MenuItem)
		if mtype == MenuType.Separator then
			app.menuNumber = app.menuNumber + 1
			this.kind = MenuType.Separator
			this.parentHandle = pHandle
		else
			if mtype == MenuType.BaseMenu or mtype == MenuType.DropDownMenu then
				this._popup = true
			else
				this._popup = false
			end

		    if this._popup then
		    	this.handle = CreatePopupMenu()
		    else
		    	this.handle = CreateMenu()
		    end

		    this._index = indexNum
		    this.idNum = app.menuNumber
		    this.text = menutxt
		    this._wideText = toUTF16(this.text)
		    this.kind = mtype
		    this.parentHandle = pHandle
		    this.bgColor = Color.new(0xe9ecef)
		    this.fgColor = Color.new(0x000000)
		    this._isEnabled = true
		    app.menuNumber = app.menuNumber + 1
		end
		return this
	end

	-- Private
	function menubar_additems_internal(mbar: *MenuBar, items: span(string))
		for _, sitem in ipairs(items) do
			local mi = MenuItem.new(sitem, MenuType.BaseMenu, mbar.handle, mbar._menuCount)
			mbar._menuCount = mbar._menuCount + 1
			mi._mbar = mbar
	        mi._formHwnd = mbar._pForm.handle
	        mi._formMenu = true
	        mbar.menus[sitem] = mi
	        mbar._pForm._menuList:push(mi)
		end
	end

	--Private function
	function MenuItem:changeType()
		if self.kind == MenuType.NormalMenu then
			self.kind = MenuType.DropDownMenu
		end
		self._popup = true
	end

	function MenuBar:addItem(menuTxt: string): *MenuItem
		local mtype = menuTxt == "|" and MenuType.Separator or MenuType.BaseMenu
		local mi: *MenuItem = MenuItem.new(menuTxt, mtype, self.handle, self._menuCount)
		mi._mbar = self
		self._menuCount =  self._menuCount + 1
		self.menus[menuTxt] = mi
		self._pForm._menuList:push(mi)
		return mi
	end

	function MenuItem:addItem(txt: string): *MenuItem
		self:changeType()
		self._popup = true
		local mi: *MenuItem = MenuItem.new(txt, MenuType.NormalMenu, self.handle, self._menuCount)
		mi._formHwnd = self._formHwnd
		mi._formMenu = true
		mi._mbar = self._mbar
		self._menuCount =  self._menuCount + 1
		self.menus[txt] = mi
		self._mbar._pForm._menuList:push(mi)
		return mi
	end

	function MenuItem:addItems(menuitems: span(string))
		self:changeType()
		for _, sitem in ipairs(menuitems) do
			local typ : MenuType = sitem == "|" and MenuType.Separator or MenuType.NormalMenu
			-- if typ == MenuType.Seperator then sitem = nil end
			local mi = MenuItem.new(sitem, typ, self.handle, self._menuCount)
			self._menuCount =  self._menuCount + 1
	        mi._formHwnd = self._mbar._pForm.handle
	        mi._mbar = self._mbar
	        mi._formMenu = true
	        self.menus[sitem] = mi
	        self._mbar._pForm._menuList:push(mi)
		end
	end

	function MenuItem:insertMenuInternal()
		local mii : MENUITEMINFO
	    mii.cbSize = #MENUITEMINFO
	    mii.fMask = MIIM_ID | MIIM_TYPE | MIIM_DATA | MIIM_SUBMENU | MIIM_STATE
	    mii.fType = MF_OWNERDRAW
	    mii.dwTypeData = self._wideText
	    mii.cch = #self.text
	    mii.dwItemData =  (@ULONG_PTR)((self))
	    mii.wID = self.idNum
	    mii.hSubMenu = self._popup and self.handle or nilptr
	    InsertMenuItemW(self.parentHandle, self.idNum, 1, &mii)
	    self._isCreated = true

	end

	--Private function

	function MenuItem:createHandle()
		-- print(string.format("Menu handle for %s is %d", self.text, (@integer)(self.handle)))
		switch self.kind do
		case MenuType.BaseMenu, MenuType.DropDownMenu then
			if self._menuCount > 0 then
				for _, menu in pairs(self.menus) do
					menu:createHandle()
				end
			end
			self:insertMenuInternal()

		case MenuType.NormalMenu then self:insertMenuInternal()
		case MenuType.Separator then
			-- print(string.format("p handle in sep : %d", (@integer)(self.parentHandle)))
			AppendMenuW(self.parentHandle, MF_SEPARATOR, 0, nilptr)
		end
	end

	function MenuBar:createHandle()
		self._menuDefBgBrush = Color.getHBrush(0xe9ecef)
	    self._menuHotBgBrush = Color.getHBrush(0x90e0ef)
	    self._menuFrameBrush = Color.getHBrush(0x0077b6)
		if self.font.handle == nilptr then self.font:createHandle() end

	    -- If there are menus, we need to create the handles for them too.
	    if self._menuCount > 0 then
			for _, menu in pairs(self.menus) do
				menu:createHandle()
			end
		end
	    SetMenu(self._pForm.handle, self.handle)
	end

	function Form:addMenuBar(items: span(string)): *MenuBar
		local mbar = MenuBar.new(self, items)
		self.menubar = mbar
		return mbar
	end

	function MenuItem:getChildMenuFromID(idnum: UINT) : (boolean, *MenuItem)
	    if self._menuCount > 0 then
	        for _, menu in pairs(self.menus) do
	            if menu.idNum == idnum then return true, menu end
	        end
	    end
	    return false, nilptr
	end
-- End of MenuBar related code

-- ===========================================Context Menu==============================================================
	local function cmenuWndProc(hw: HWND, msg: UINT, wpm: WPARAM, lpm: LPARAM, scID: UINT_PTR, refData: DWORD_PTR): LRESULT <forwarddecl> end

	local function createDummyControl(pHwnd: HWND): HWND
		return CreateWindowExW(0, toUTF16("Button"), nilptr, WS_CHILD,
								0, 0, 0, 0, pHwnd, nilptr, app.hInstance, nilptr)
	end

	function ContextMenu.new(ctl: ControlConcept) : *ContextMenu
		local this : *ContextMenu = default_allocator:new(@ContextMenu)
	    this.parent = ctl
	    this.handle = CreatePopupMenu()
	    this._rightClick = true
	    this.font = ctl.font
	    this.width = 120
	    this.height = 25
	    this._defBgBrush = Color.getHBrush(0xe9ecef)
	    this._hotBgBrush = Color.getHBrush(0x90e0ef)
	    this._borderBrush = Color.getHBrush(0x0077b6)
	    -- this._selTxtClr = Color.new(0x000000)
	    this._grayBrush = Color.getHBrush(0xced4da)
	    this._grayCref = Color.getColorRef(0x979dac)
	    this._dummyHwnd = createDummyControl(ctl.handle)
	    setSubClass(this._dummyHwnd, this, cmenuWndProc)
	    return this
	end

	global function addContextMenu(ctl: ControlConcept, items: span(string))
		local cmenu = ContextMenu.new(ctl)
		ctl.contextMenu = cmenu
		if #items > 0 then
			for _, item in ipairs(items) do
				local mtyp : MenuType = item == "|" and MenuType.Separator or MenuType.ContextMenu
	            local mi = MenuItem.new(item, mtyp, cmenu.handle, cmenu._menuCount)
	            cmenu._menuCount = cmenu._menuCount + 1
	            self.menus[item] = mi
			end
		end
	end

	function MenuItem:insertCmenuInternal()
		if #self.menus > 0 then
			for _, menu in pairs(self.menus) do
				menu:insertCmenuInternal()
			end
		end
		if self.kind == MenuType.ContextMenu then
            self:insertMenuInternal()
        elseif self.kind == MenuType.Separator then
            AppendMenuW(self.handle, MF_SEPARATOR, 0, nilptr)
        end
	end

	function ContextMenu:createCmenuHandle()
		if #self.menus > 0 then
			for _, menu in pairs(self.menus) do
				menu:insertCmenuInternal()
			end
		end
		self._menuInserted = true
	end

	function ContextMenu:addItem(item: string)
		local mtyp : MenuType = item == "|" and MenuType.Separator or MenuType.ContextMenu
        local mi = MenuItem.new(item, mtyp, self.handle, self._menuCount)
        self._menuCount = self._menuCount + 1
        self.menus[item] = mi
    end

    function ContextMenu:addItems(items: span(string))
    	if #items > 0 then
			for _, item in ipairs(items) do
				local mtyp : MenuType = item == "|" and MenuType.Separator or MenuType.ContextMenu
	            local mi = MenuItem.new(item, mtyp, self.handle, self._menuCount)
	            self._menuCount = self._menuCount + 1
	            self.menus[item] = mi
			end
		end
    end

    function ContextMenu:show(lpm: LPARAM)
    	if not self._menuInserted then self:createCmenuHandle() end
    	local pt = getMousePos(lpm)
	    if pt.x == -1 or pt.y == -1 then
	        -- ContextMenu message generated by keybord shortcut.
	        -- So we need to find the mouse position.
	        pt = getMousePosOnMsg()
	    end
	    local mBtn : UINT = self._rightClick and TPM_RIGHTBUTTON or TPM_LEFTBUTTON
	    TrackPopupMenu(self.handle, mBtn, pt.x, pt.y, 0, self._dummyHwnd, nilptr)
	end

	function ContextMenu:getMenuItemFromID(idnum: UINT): (*MenuItem, boolean)
		if #self.menus > 0 then
	        for _, menu in pairs(self.menus) do
	            if menu.idNum == idnum then return menu, true end
	        end
	    end
	    return nilptr, false
	end

	function Form:addContextMenu(items: span(string))
		self.contextMenu = ContextMenu.new(self)
		self.contextMenu:addItems(items)
	end

	function cmenuWndProc(hw: HWND, msg: UINT, wpm: WPARAM, lpm: LPARAM, scID: UINT_PTR, refData: DWORD_PTR): LRESULT
		local cmenu = (@*ContextMenu)((pointer)(refData))
		switch msg do
		case WM_DESTROY then
			-- print("cmenu destroyed")
			DestroyMenu(cmenu.handle)
			RemoveWindowSubclass(hw, cmenuWndProc, scID)

		case WM_MEASUREITEM then
	        local pmi = (@LPMEASUREITEMSTRUCT)(lpm)
	        pmi.itemWidth = cmenu.width
	        pmi.itemHeight = cmenu.height
	        return 1

	    case WM_DRAWITEM then
	        local dis = (@LPDRAWITEMSTRUCT)(lpm)
	        local mi = (@*MenuItem)(dis.itemData)
	        local txtClrRef : COLORREF = mi.fgColor.ref
	        if dis.itemState == 257 then
	            if mi._isEnabled then
	                local rc = RECT{dis.rcItem.left + 4, dis.rcItem.top + 2, dis.rcItem.right, dis.rcItem.bottom - 2}
	                FillRect(dis.hDC, &rc, cmenu._hotBgBrush)
	                FrameRect(dis.hDC, &rc, cmenu._borderBrush)
	                txtClrRef = 0x00000000
	            else
	                FillRect(dis.hDC, &dis.rcItem, cmenu._grayBrush)
	                txtClrRef = cmenu._grayCref
	            end
	        else
	            FillRect(dis.hDC, &dis.rcItem, cmenu._defBgBrush)
	            if not mi._isEnabled then txtClrRef = cmenu._grayCref end
	        end

	        SetBkMode(dis.hDC, 1)
	        dis.rcItem.left = dis.rcItem.left + 25
	        SelectObject(dis.hDC, cmenu.font.handle)
	        SetTextColor(dis.hDC, txtClrRef)
	        DrawTextW(dis.hDC, mi._wideText, -1, &dis.rcItem, DT_LEFT | DT_SINGLELINE | DT_VCENTER)
	        return 0

	    case WM_ENTERMENULOOP then
	        if cmenu.onMenuShown ~= nilptr then
	            local ea : EventArgs = {}
	            cmenu.onMenuShown(cmenu, &ea)
	        end
	    case WM_EXITMENULOOP then
	        if cmenu.onMenuClose ~= nilptr then
	            local ea : EventArgs = {}
	            cmenu.onMenuClose(cmenu, &ea)
	        end
	    case WM_MENUSELECT then
	        local idNumber = (@UINT)(loWord(wpm))
	        local hMenu = (@HMENU)(lpm)
	        if hMenu ~= nilptr and idNumber > 0 then
	            local menu, okay = cmenu:getMenuItemFromID(idNumber)
	            if okay and menu._isEnabled then
	                if menu.onFocus ~= nilptr then
	                    local ea : EventArgs = {}
	                    menu.onFocus(menu, &ea)
	                end
	            end
	        end
	    case WM_COMMAND then
	        local idNumber = (@UINT)(loWord(wpm))
	        if idNumber > 0 then
	            local menu, okay = cmenu:getMenuItemFromID(idNumber)
	            if okay and menu._isEnabled then
	                if menu.onClick ~= nilptr then
	                    local ea : EventArgs = {}
	                    menu.onClick(menu, &ea)
	                end
	            end
	        end
		end
		return DefSubclassProc(hw, msg, wpm, lpm)
	end

-- End of Context Menu
