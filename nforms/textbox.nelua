-- Textbox module - Created on 05-Mar-2023 07:18 AM




require "nforms.api_messages"
require "nforms.apifuncs"
require "nforms.forms"
require "nforms.common"

--Constants
	local ECM_FIRST <comptime> = 0x1500
	local ES_LEFT <comptime> = 0
	local ES_AUTOHSCROLL <comptime> = 128
	local ES_MULTILINE <comptime> = 4
	local ES_WANTRETURN <comptime> = 4096
	local ES_NOHIDESEL <comptime> = 256
	local ES_READONLY <comptime> = 0x800
	local ES_LOWERCASE <comptime> = 16
	local ES_UPPERCASE <comptime> = 8

	local ES_NUMBER <comptime> = 0x2000
	local ES_PASSWORD <comptime> = 32
	local ES_CENTER <comptime> = 1
	local ES_RIGHT <comptime> = 2
	local EM_SETCUEBANNER <comptime> = ECM_FIRST + 1
--End

local tbStyle <comptime> =  WS_CHILD|WS_VISIBLE|ES_LEFT|WS_TABSTOP|ES_AUTOHSCROLL|WS_MAXIMIZEBOX|WS_OVERLAPPED
local tbExStyle <comptime> = WS_EX_LEFT|WS_EX_LTRREADING|WS_EX_CLIENTEDGE|WS_EX_NOPARENTNOTIFY

local function tbWndProc(hw: HWND, msg: UINT, wpm: WPARAM, lpm: LPARAM, scID: UINT_PTR, refData: DWORD_PTR): LRESULT <forwarddecl> end

global TextCase = @enum {Default = 0, LowerCase, UpperCase}
global TextType = @enum {Default = 0, NumberOnly, PasswordChar}


global TextBox = @record
{
	name : string,
	text : string,
	cueBanner: string,
	className: LPCWSTR,
	handle : HWND,
	width : integer,
	height : integer,
	xpos : integer,
	ypos : integer,
	font: Font,
	parent : *Form,
	backColor: Color,
	foreColor: Color,
	alignment: TextAlign,
	textCase: TextCase,
	textType: TextType,
	multiLine: boolean,
	hideSelection: boolean,
	readOnly: boolean,

	_isCreated: boolean,
	_isTextable: boolean,
	_style: DWORD,
	_exStyle: DWORD,
	_lbDown: boolean,
	_rbDown: boolean,
	_isMouseEntered: boolean,
	_drawFlag: uinteger,
	_bkBrush: HBRUSH,


	onMouseDown: MouseEventHandler,
	onMouseUp: MouseEventHandler,
	onClick: EventHandler,
	onRightMouseDown: MouseEventHandler,
	onRightMouseUp: MouseEventHandler,
	onRightClick: EventHandler,
	onMouseScroll: MouseEventHandler,
	onMouseEnter: EventHandler,
	onMouseMove: MouseEventHandler,
	onMouseLeave: EventHandler,
	onTextChanged: EventHandler,
	onKeyDown: KeyEventHandler,
	onKeyUp: KeyEventHandler,
	onKeyPress: KeyEventHandler,

}

-- Public function
function TextBox.new(frm : *Form, txt: string, x: integer, y: integer, w: integer, h: integer) : TextBox
	local this : TextBox
	this.name = "TextBox_1"
	this.className = toUTF16("Edit")
	this.text = txt == "" and this.name or txt
	this.width = w == 0 and 140 or w
	this.height = h == 0 and 27 or h
	this.xpos = x == 0 and 20 or x
	this.ypos = y == 0 and 20 or y
	this.font = frm.font
	this.parent = frm
	this._style = tbStyle
	this._exStyle = tbExStyle
	this._isTextable = true
	this.backColor = colorWhite
	this.foreColor = colorBlack
	return this
end

function TextBox:setTbStyles()
	if self.multiLine then self._style = self._style | ES_MULTILINE | ES_WANTRETURN end
    if not self.hideSelection then self._style = self._style| ES_NOHIDESEL end
    if self.readOnly then self._style = self._style| ES_READONLY end

    if self.textCase == TextCase.LowerCase then
		self._style = self._style | ES_LOWERCASE
    elseif self.textCase == TextCase.UpperCase then
		self._style = self._style|ES_UPPERCASE
	end

    if self.textType == TextType.NumberOnly then
		self._style = self._style|ES_NUMBER
    elseif self.textType == TextType.PasswordChar then
		self._style = self._style|ES_PASSWORD
	end

    if self.alignment == TextAlign.Center then
		self._style = self._style|ES_CENTER
    elseif self.alignment == TextAlign.Right then
		self._style = self._style|ES_RIGHT
	end
    self._bkBrush = CreateSolidBrush(self.backColor.ref)
end




-- Public function
function TextBox:createHandle()
	self:setTbStyles()
	createControl(self)
	if self._isCreated then
		setSubClass(self.handle, (pointer)(self), tbWndProc)
		if #self.cueBanner > 0 then sendMsg(self, EM_SETCUEBANNER, 1, toUTF16(self.cueBanner)) end

	end
end

function TextBox:setText(txt: string)
	self.text = txt
	if self._isCreated then	setControlText(self.handle, txt) end
end

function TextBox:getText(txt: string): string
	if self._isCreated then
		local wstr = getControlText(self.handle)
		self.text = toUTF8(wstr)
		return self.text
	else
		return self.text
	end
end



function TextBox:destroy()
	print("TextBox destroyed")
	DeleteObject(self._bkBrush)

end

-- -- Public function
-- function TextBox:setForeColor(clr: uinteger)
-- 	self.foreColor = Color.new(clr)
-- 	if (self._drawFlag & 1) ~= 1 then self._drawFlag = self._drawFlag + 1 end
-- 	invalidateNow(self)
-- end

-- -- Public function
-- function TextBox:setBackColor(clr: uinteger)
-- 	self.backColor = Color.new(clr)
-- 	if (self._drawFlag & 2) ~= 2 then self._drawFlag = self._drawFlag + 2 end
-- 	self._fdraw:init(self.backColor)
-- 	invalidateNow(self)
-- end

-- -- Public function
-- function TextBox:setGradientColor(clr1: uinteger, clr2: uinteger)
-- 	self._gdraw:init(clr1, clr2)
-- 	if (self._drawFlag & 4) ~= 4 then self._drawFlag = self._drawFlag + 4 end
-- 	invalidateNow(self)
-- end

-- local function setBtnForColorInternal(this: *TextBox, nmcd: *NMCUSTOMDRAW): LRESULT
-- 	SetTextColor(nmcd.hdc, this.foreColor.ref)
-- 	SetBkMode(nmcd.hdc, 1)
-- 	DrawTextW(nmcd.hdc, toUTF16(this.text), -1, &nmcd.rc, b_txt_flag)
-- 	return CDRF_NOTIFYPOSTPAINT
-- end

-- local function paintFlatTextBox(hdc: HDC, rc: RECT, hbr: HBRUSH, pen: HPEN)
-- 	SelectObject(hdc, hbr)
-- 	SelectObject(hdc, pen)
-- 	RoundRect(hdc, rc.left, rc.top, rc.right, rc.bottom, btn_round_factor, btn_round_factor)
-- 	FillPath(hdc)
-- end

-- local function paintGradientTextBox(hdc: HDC, rc: RECT, gc: GradColor, pen: HPEN)
-- 	local gBrush: HBRUSH = createGradientBrush(hdc, rc, gc.c1, gc.c2, true)
-- 	defer DeleteObject(gBrush) end

-- 	SelectObject(hdc, pen)
-- 	SelectObject(hdc, gBrush)
-- 	RoundRect(hdc, rc.left, rc.top, rc.right, rc.bottom, btn_round_factor, btn_round_factor)
-- 	FillPath(hdc)
-- end


-- local function setBtnBackColorInternal(this: *TextBox, nmcd: *NMCUSTOMDRAW): LRESULT
-- 	switch nmcd.dwDrawStage do
-- 	case CDDS_PREERASE then return CDRF_NOTIFYPOSTERASE
-- 	case CDDS_PREPAINT then
-- 		if (nmcd.uItemState & mouse_clicked) == mouse_clicked then
-- 			paintFlatTextBox(nmcd.hdc, nmcd.rc, this._fdraw.defBrush, this._fdraw.hotPen)
-- 		elseif (nmcd.uItemState & mouse_over) == mouse_over then
-- 			paintFlatTextBox(nmcd.hdc, nmcd.rc, this._fdraw.hotBrush, this._fdraw.hotPen)
-- 		else
-- 			paintFlatTextBox(nmcd.hdc, nmcd.rc, this._fdraw.defBrush, this._fdraw.defPen)
-- 		end
-- 		return CDRF_DODEFAULT
-- 	end
-- 	return CDRF_DODEFAULT
-- end

-- local function setBtnGradientColorInternal(this: *TextBox, nmcd: *NMCUSTOMDRAW): LRESULT
-- 	switch nmcd.dwDrawStage do
-- 	case CDDS_PREERASE then return CDRF_NOTIFYPOSTERASE
-- 	case CDDS_PREPAINT then
-- 		if (nmcd.uItemState & mouse_clicked) == mouse_clicked then
-- 			paintGradientTextBox(nmcd.hdc, nmcd.rc, this._gdraw.defGC, this._gdraw.hotPen)
-- 		elseif (nmcd.uItemState & mouse_over) == mouse_over then
-- 			paintGradientTextBox(nmcd.hdc, nmcd.rc, this._gdraw.hotGC, this._gdraw.hotPen)
-- 		else
-- 			paintGradientTextBox(nmcd.hdc, nmcd.rc, this._gdraw.defGC, this._gdraw.defPen)
-- 		end
-- 		return CDRF_DODEFAULT
-- 	end
-- 	return CDRF_DODEFAULT
-- end

-- local function btnWmNotifyHandler(this: *TextBox, lp: LPARAM): LRESULT
-- 	local ret = CDRF_DODEFAULT
-- 	if this._drawFlag then
-- 		local nmcd = (@*NMCUSTOMDRAW)(lp)
-- 		switch this._drawFlag do
-- 			case 1 then return setBtnForColorInternal(this, nmcd)
-- 			case 2 then return setBtnBackColorInternal(this, nmcd)
-- 			case 3 then
-- 				setBtnBackColorInternal(this, nmcd)
-- 				return setBtnForColorInternal(this, nmcd)
-- 			case 4 then return setBtnGradientColorInternal(this, nmcd)
-- 			-- case 5 then
-- 		end
-- 	end
-- 	return ret
-- end

function tbWndProc(hw: HWND, msg: UINT, wpm: WPARAM, lpm: LPARAM, scID: UINT_PTR, refData: DWORD_PTR): LRESULT
	local this = (@*TextBox)((pointer)(refData))
	switch msg do
	case WM_DESTROY then
	    RemoveWindowSubclass(hw, tbWndProc, scID)
		this:destroy()

	case WM_LBUTTONDOWN then leftMouseDownHandler(this, msg, wpm, lpm)
	case WM_LBUTTONUP then leftMouseUpHandler(this, msg, wpm, lpm)
	case MM_MOUSE_LB_CLICK then leftMouseClickHandler(this)
	case WM_RBUTTONDOWN then rightMouseDownHandler(this, msg, wpm, lpm)
	case WM_RBUTTONUP then rightMouseUpHandler(this, msg, wpm, lpm)
	case MM_MOUSE_RB_CLICK then rightMouseClickHandler(this)
	case WM_MOUSEHWHEEL then mouseScrollHandler(this, msg, wpm, lpm)
	case WM_MOUSEMOVE then mouseMoveHandler(this, msg, wpm, lpm)
	case WM_MOUSELEAVE then mouseLeaveHandler(this)

	-- case MM_NOTIFY_REFLECT then	return btnWmNotifyHandler(this, lpm)


	end

	return DefSubclassProc(hw, msg, wpm, lpm)
end
